# ================================================================
# lab3_part1_v1_<user>.tcl
# Лабораторная работа №3, Часть 1
# Вариант 1
# Исходное выражение:
#   set a 10
#   set b "{$a}\{ #[set c 14]}"
# Задание:
#   Подобрать такие выражения для b, чтобы получить результаты (a–h).
# ================================================================

# Базовая установка
set a 10
puts "Variable a initialized: a = $a"
puts "-------------------------------------------------------------"

# === Вариант (a): {10}{  ===
# Здесь мы хотим, чтобы подставилось значение a (10),
# а подстановка [set c 14] не выполнялась и часть строки после # ушла в комментарий.
# Это возможно, если убрать кавычки — # запускает комментарий.
puts "\n--- Variant (a) ---"
# Команда до комментария
set b "{$a}{ "  ;# комментарий начинается после пробела и #
puts "Result: '$b'"
puts "Explanation: подстановка \$a выполнена, но после символа { строка обрезана комментарием. => {10}{"

# === Вариант (b): 10{ #14 ===
puts "\n--- Variant (b) ---"
# В двойных кавычках выполняются подстановки, но фигурные скобки — обычные символы.
# Здесь [set c 14] выполняется и возвращает 14, без внешних фигурных скобок вокруг всего.
set b "$a{ #[set c 14]"
puts "Result: '$b'"
puts "Explanation: \$a подставлен (10), [set c 14] выполнен (вернул 14), внутри кавычек всё соединено => 10{ #14"

# === Вариант (c): {10}{ #[set c 14] ===
puts "\n--- Variant (c) ---"
# Чтобы сохранить [set c 14] как текст, нужно экранировать квадратные скобки.
set b "{$a}{ \#\[set c 14\]}"
puts "Result: '$b'"
puts "Explanation: \$a подставлен (10), \[set c 14\] экранированы, потому не выполняются. => {10}{ #[set c 14]"

# === Вариант (d): $a{ #14 ===
puts "\n--- Variant (d) ---"
# Экранируем $ чтобы он не подставился, но оставляем подстановку команды.
set b "\$a{ #[set c 14]"
puts "Result: '$b'"
puts "Explanation: \$a не подставлен (остался как текст), [set c 14] выполнен => \$a{ #14"

# === Вариант (e): {10}{ #14 ===
puts "\n--- Variant (e) ---"
# Это исходное выражение из теста — правильный вариант.
set b "{$a}\{ #[set c 14]}"
puts "Result: '$b'"
puts "Explanation: \$a подставлен (10), \{ превращается в {, [set c 14] выполняется (возвращает 14). => {10}{ #14"

# === Вариант (f): {$a}\{ #[set c 14] ===
puts "\n--- Variant (f) ---"
# Чтобы полностью подавить подстановку и сохранить строку как есть, используем фигурные кавычки.
set b "{\$a}\\{ #\[set c 14\]"
puts "Result: '$b'"
puts "Explanation: фигурные кавычки отключают все подстановки => текст сохраняется буквально => {$a}\\{ #[set c 14]"

# === Вариант (g): {$a}{ #14 ===
puts "\n--- Variant (g) ---"
# Здесь хотим сохранить $a как текст, но выполнить [set c 14]
set b "{\$a}{ #[set c 14]"
puts "Result: '$b'"
puts "Explanation: \$a не подставлен (остался текстом), но [set c 14] выполнен => {\$a}{ #14"

# === Вариант (h): syntax error ===
puts "\n--- Variant (h) ---"
# Пример синтаксической ошибки: незакрытые кавычки или фигурные скобки
catch {
    set b "{$a}{ #[set c 14]"
} err
puts "Result: syntax error occurred"
puts "Tcl error message: $err"
puts "Explanation: несбалансированные фигурные скобки вызывают синтаксическую ошибку."